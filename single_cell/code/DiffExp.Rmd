---
title: "scRNAseq Analysis - Pseudobulk DE analysis with DESeq2"
output: html_notebook
author: Talia Wiggen
---
# Description
This notebook is adapted from: https://hbctraining.github.io/scRNA-seq_online/lessons/pseudobulk_DESeq2_scrnaseq.html

The objective of this notebook is to prepare single-cell RNA-seq raw count data for pseudobulk differential expression analysis and use the DESeq2 tool to perform pseudobulk differential expression analysis. The approach for pseudobulk differential expression analysis is:
1. Subsetting to the cells for the cell type(s) of interest to perform the DE analysis.
2. Extracting the raw counts after QC filtering of cells to be used for the DE analysis
3. Aggregating the counts and metadata to the sample level.
4. Performing the DE analysis (Need at least two biological replicates per condition to perform the analysis, but more replicates are recommended)




# Setup Environment
```{r}
# Load libraries
library(Seurat)
library(tidyverse)
library(cowplot)
library(Matrix.utils)
library(edgeR)
library(dplyr)

library(Matrix)
library(purrr)
library(reshape2)
library(S4Vectors)
library(tibble)
library(SingleCellExperiment)
library(pheatmap)
library(apeglm)
library(png)
library(DESeq2)

library(EnhancedVolcano)
```
```{r}
library(RColorBrewer)
library(magrittr)
```

# Subset and extract cells
```{r}
# Bring in Seurat object
seurat <- readRDS("../data/seurat/seurat_labelled.rds")

# Extract raw counts and metadata to create SingleCellExperiment object
counts <- seurat@assays$RNA@counts 

metadata <- seurat@meta.data

# Set up metadata as desired for aggregation and DE analysis
metadata$cluster_id <- factor(seurat@active.ident)

# Create single cell experiment object
sce <- SingleCellExperiment(assays = list(counts = counts), 
                           colData = metadata)
```


```{r}
# Identify groups for aggregation of counts
groups <- colData(sce)[, c("cluster_id", "sample")]
```

```{r}
# Explore the raw counts for the dataset

## Check the assays present
assays(sce)

## Explore the raw counts for the dataset
dim(counts(sce))

counts(sce)[1:6, 1:6]
```

```{r}
## Explore the cellular metadata for the dataset
dim(colData(sce))

head(colData(sce))
```
```{r}
#save annotations file
annotations <- read.csv("../data/annotation.csv")
```


# Acquiring necessary metrics for aggregation across cells in a sample
First, we need to determine the number of clusters and the cluster names present in our dataset.
```{r}
# Named vector of cluster names
kids <- purrr::set_names(levels(sce$cluster_id))
kids

# Total number of clusters
nk <- length(kids)
nk

# Named vector of sample names
sce$sample <- as.factor(sce$sample)
sids <- purrr::set_names(levels(sce$sample))
sids

# Total number of samples 
ns <- length(sids)
ns
```

To perform sample-level differential expression analysis, we need to generate sample-level metadata. To do this, we will reorder samples in the single-cell metadata to match the order of the factor levels of the sample ID, then extract only the sample-level information from the first cell corresponding to that sample.
```{r}
# Generate sample level metadata

## Determine the number of cells per sample
table(sce$sample)

## Turn named vector into a numeric vector of number of cells per sample
n_cells <- as.numeric(table(sce$sample))

## Determine how to reorder the samples (rows) of the metadata to match the order of sample names in sids vector
m <- match(sids, sce$sample)

## Create the sample level metadata by combining the reordered metadata with the number of cells corresponding to each sample.
ei <- data.frame(colData(sce)[m, ], 
                 n_cells, row.names = NULL) %>% 
  select(-"cluster_id")
ei
```

Now, we are ready for aggregation of counts to the sample level. Essentially, we are taking the sum of counts for each sample within each cell type.

# Count aggregation to sample level
```{r}
# Aggregate the counts per sample_id and cluster_id

# Subset metadata to only include the cluster and sample IDs to aggregate across
groups <- colData(sce)[, c("cluster_id", "sample")]

# Aggregate across cluster-sample groups
pb <- aggregate.Matrix(t(counts(sce)), 
                       groupings = groups, fun = "sum") 

class(pb)

dim(pb)

pb[1:6, 1:6] 
```

The output of this aggregation is a sparse matrix, and when we take a quick look, we can see that it is a gene by cell type-sample matrix.

To perform DE analysis on a per cell type basis, we need to wrangle our data in a couple ways. We need to do the following steps:
1. Split our data by cell type
2. Transform the matrix so that the genes are the row names and the samples are the column names

We will split our data by cell type; however, not always do all samples contain cells of every cell type. To determine which samples are present for each cell type we can run the following:
```{r}
# Not every cluster is present in all samples; create a vector that represents how to split samples
splitf <- sapply(stringr::str_split(rownames(pb), 
                                    pattern = "_",  
                                    n = 2), 
                 `[`, 1)
```

Now we can turn the matrix into a list that is split into count matrices for each cluster, then transform each data frame so that rows are genes and columns are the samples.

```{r}
# Turn into a list and split the list into components for each cluster and transform, so rows are genes and columns are samples and make rownames as the sample IDs
pb <- split.data.frame(pb, 
                       factor(splitf)) %>%
  lapply(function(u) 
    set_colnames(t(u), 
                 stringr::str_extract(rownames(u), "(?<=_)[:alnum:]+")))

class(pb)

# Explore the different components of list
str(pb)
```
The counts per sample for each cluster can be checked:
```{r}
# Print out the table of cells in each cluster-sample group
options(width = 100)
table(sce$cluster_id, sce$sample)
```

# DESeq
## Sample Metadata
First, we will create a vector of sample names combined for each of the cell type clusters.
```{r}
# Get sample names for each of the cell type clusters

# prep. data.frame for plotting
get_sample_ids <- function(x){
  pb[[x]] %>%
    colnames()
}

de_samples <- map(1:length(kids), get_sample_ids) %>%
  unlist()
```

Then we can get the cluster IDs corresponding to each of the samples in the vector.
```{r}
# Get cluster IDs for each of the samples

samples_list <- map(1:length(kids), get_sample_ids)

get_cluster_ids <- function(x){
  rep(names(pb)[x], 
      each = length(samples_list[[x]]))
}

de_cluster_ids <- map(1:length(kids), get_cluster_ids) %>%
  unlist()
```

Finally, let’s create a data frame with the cluster IDs and the corresponding sample IDs. We will merge together the condition information.
```{r}
# Create a data frame with the sample IDs, cluster IDs and condition

gg_df <- data.frame(cluster_id = de_cluster_ids,
                    sample = de_samples)

gg_df <- left_join(gg_df, ei[, c("sample", "condition")]) 


metadata <- gg_df %>%
  dplyr::select(cluster_id, sample, condition) 

metadata$cluster_id <- factor(metadata$cluster_id)

head(metadata, n = 10)
```

## Subsetting data to clusters of interest
Now that we have the sample-level metadata and sample-level counts, we can run the differential expression analysis with DESeq2. Oftentimes, we would like to perform the analysis on multiple different clusters, so we can set up the workflow to run easily on any of our clusters.

To do this we can create a clusters vector of all of the cluster cell type IDs in our dataset. Then we can select the cell type we wish to perform the DE analysis on.

Let’s take a look at the cluster cell type IDs:
```{r}
# Generate vector of cluster IDs
clusters <- levels(metadata$cluster_id)
clusters
```

# Basal cells
We see multiple different immune cell types in our dataset. Let’s perform the DE analysis on the first element in our vector. Let’s extract the first eleement from the vector:
```{r}
clusters[1]
```

We can use this output to run the DE analysis on the first cluster. First we can subset the metadata and the counts to only the cells in the first cluster.
```{r}
# Subset the metadata to only the B cells
cluster_metadata <- metadata[which(metadata$cluster_id == clusters[1]), ]
head(cluster_metadata)

# Assign the rownames of the metadata to be the sample IDs
rownames(cluster_metadata) <- cluster_metadata$sample
cluster_metadata

# Subset the counts to only the B cells
counts <- pb[[clusters[1]]]

cluster_counts <- as.data.frame(as.matrix(counts[, which(colnames(counts) %in% rownames(cluster_metadata))]))

# Check that all of the row names of the metadata are the same and in the same order as the column names of the counts in order to use as input to DESeq2
all(rownames(cluster_metadata) == colnames(cluster_counts))         
```

## Create DESeq2 object
Now we can create our DESeq2 object to prepare to run the DE analysis. We need to include the counts, metadata, and design formula for our comparison of interest. In the design formula we should also include any other columns in the metadata for which we want to regress out the variation (e.g. batch, sex, age, etc.). We only have our comparison of interest, which is stored as the condition in our metadata data frame.

```{r}
# Create DESeq2 object        
dds <- DESeqDataSetFromMatrix(cluster_counts, 
                              colData = cluster_metadata, 
                              design = ~ condition)
```

```{r}
dds$condition<- relevel(dds$condition, ref = "ana")
```

## Quality Control
The next step in the DESeq2 workflow is QC, which includes sample-level and gene-level QC checks on the count data to help us ensure that the samples/replicates look good.

### Sample level
A useful initial step in an RNA-seq analysis is to assess overall similarity between samples:
 - Which samples are similar to each other, which are different?
 - Does this fit the expectation from the experiment’s design?
 - What are the major sources of variation in the dataset?
 
To explore the similarity of our samples, we will be performing sample-level QC using Principal Component Analysis (PCA) and hierarchical clustering methods. Sample-level QC allows us to see how well our replicates cluster together, as well as, observe whether our experimental condition represents the major source of variation in the data. Performing sample-level QC can also identify any sample outliers, which may need to be explored further to determine whether they need to be removed prior to DE analysis.

### PCA
We can run the rlog() function from DESeq2 to normalize and rlog transform the raw counts. Then, we can use the plotPCA() function to plot the first two principal components.
```{r}
# Transform counts for data visualization
rld <- rlog(dds, blind=TRUE)

# Plot PCA
DESeq2::plotPCA(rld, intgroup = "condition")
```

### Hierarchical clustering
Samples below 0.80 may indicate an outlier in your data and/or sample contamination.

The hierarchical tree can indicate which samples are more similar to each other based on the normalized gene expression values. The color blocks indicate substructure in the data, and you would expect to see your replicates cluster together as a block for each sample group. Additionally, we expect to see samples clustered similar to the groupings observed in a PCA plot.
```{r}
# Extract the rlog matrix from the object and compute pairwise correlation values
rld_mat <- assay(rld)
rld_cor <- cor(rld_mat)

# Plot heatmap
pheatmap(rld_cor, annotation = cluster_metadata[, c("condition"), drop=F])
```

## Running DESeq2
Briefly, DESeq2 will model the raw counts, using normalization factors (size factors) to account for differences in library depth. Then, it will estimate the gene-wise dispersions and shrink these estimates to generate more accurate estimates of dispersion to model the counts. Finally, DESeq2 will fit the negative binomial model and perform hypothesis testing using the Wald test or Likelihood Ratio Test.

```{r}
# Run DESeq2 differential expression analysis
dds <- DESeq(dds)
```

We can check the fit of the model to our data by looking at the plot of dispersion estimates.
```{r}
# Plot dispersion estimates
plotDispEsts(dds)
```

## Results
Now that we have performed the differential expression analysis, we can explore our results for a particular comparison. To denote our comparison of interest, we need to specify the contrast and perform shrinkage of the log2 fold changes.

```{r}
# Check the coefficients for the comparison
resultsNames(dds)
```


```{r}
# Generate results object
res <- results(dds, 
               name = "condition_fuso_vs_ana",
               alpha = 0.05)

# Shrink the log2 fold changes to be more appropriate using the apeglm method - should cite [paper]() when using this method
res <- lfcShrink(dds, 
                 coef = "condition_fuso_vs_ana",
                 res=res,
                 type = "apeglm")

```

### Table of results for all genes
```{r}
# Turn the results object into a tibble for use with tidyverse functions
res_tbl <- res %>%
  data.frame() %>%
  rownames_to_column(var="gene") %>%
  as_tibble() %>%
  arrange(padj) %>%
  left_join(annotations, by = c("gene" = "gene_name")) # Join annotation data to dataframe

# Check results output
res_tbl 

# Write all results to file
write.csv(res_tbl,
          paste0("../results/", clusters[1], "_all_genes.csv"),
          quote = FALSE, 
          row.names = FALSE)
```

### Table of results for significant genes
```{r}
# Set thresholds
padj_cutoff <- 0.05
l2fc.cutoff <- 1
##NOTE: Here we are just using a p-value cutoff to denote significance. We could also add a log2fc filter as well.

# Subset the significant results
sig_res <- dplyr::filter(res_tbl, padj < padj_cutoff & abs(log2FoldChange) > l2fc.cutoff) %>%
  dplyr::arrange(padj)

# Check significant genes output
sig_res

# Write significant results to file
write.csv(sig_res,
          paste0("../results/", clusters[1], "_sig_genes05.csv"),
          quote = FALSE, 
          row.names = FALSE)
```

### Scatterplot 
Now that we have identified the significant genes, we can plot a scatterplot of the top 20 significant genes. This plot is a good check to make sure that we are interpreting our fold change values correctly, as well.

```{r}
# Scatterplot
## ggplot of top genes
normalized_counts <- counts(dds, 
                            normalized = TRUE)

## Order results by padj values
top20_sig_genes <- sig_res %>%
  dplyr::arrange(padj) %>%
  dplyr::pull(gene) %>%
  head(n=20)


top20_sig_norm <- data.frame(normalized_counts) %>%
  rownames_to_column(var = "gene") %>%
  dplyr::filter(gene %in% top20_sig_genes)

gathered_top20_sig <- top20_sig_norm %>%
  gather(colnames(top20_sig_norm)[2:length(colnames(top20_sig_norm))], key = "samplename", value = "normalized_counts")

gathered_top20_sig <- inner_join(ei[, c("sample", "condition" )], gathered_top20_sig, by = c("sample" = "samplename"))

## plot using ggplot2
scatter_basal<- ggplot(gathered_top20_sig) +
  geom_point(aes(x = gene, 
                 y = normalized_counts, 
                 color = condition), 
             position=position_jitter(w=0.1,h=0)) +
  scale_y_log10() +
  xlab("Genes") +
  ylab("log10 Normalized Counts") +
  ggtitle("Top Significant DE Genes") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  theme(plot.title = element_text(hjust = 0.5))
scatter_basal
```
```{r}
ggsave(scatter_basal, filename = "../results/Basal_scatter05.pdf", device = "pdf", height = 6, width = 6)
```


```{r}
# get normalized counts to export
basal_norm <- data.frame(normalized_counts)

basal_sig_norm <- data.frame(normalized_counts) %>%
  rownames_to_column(var = "gene") %>%
  dplyr::filter(gene %in% sig_res$gene)

gathered_basal_sig <- basal_sig_norm %>%
  gather(colnames(basal_sig_norm)[2:length(colnames(basal_sig_norm))], key = "samplename", value = "normalized_counts")

gathered_basal_sig <- inner_join(ei[, c("sample", "condition" )], gathered_basal_sig, by = c("sample" = "samplename"))


gathered_basal <- basal_norm %>%
  gather(colnames(basal_norm)[2:length(colnames(basal_norm))], key = "samplename", value = "normalized_counts")

gathered_basal <- inner_join(ei[, c("sample", "condition" )], gathered_basal, by = c("sample" = "samplename"))

# Write results to file
write.csv(gathered_basal_sig,
          paste0("../results/", clusters[1], "_norm_sig.csv"),
          quote = FALSE, 
          row.names = FALSE)

write.csv(gathered_basal,
          paste0("../results/", clusters[1], "_norm.csv"),
          quote = FALSE, 
          row.names = FALSE)
```

### Heatmap
```{r}
# Extract normalized counts for only the significant genes
sig_norm <- data.frame(normalized_counts) %>%
  rownames_to_column(var = "gene") %>%
  dplyr::filter(gene %in% sig_res$gene)

labels <- sig_norm$gene
# Set a color palette
heat_colors <- brewer.pal(6, "YlOrRd")

# Run pheatmap using the metadata data frame for the annotation
heatmap_basal <- pheatmap(sig_norm[ , 2:length(colnames(sig_norm))], 
         color = heat_colors, 
         cluster_rows = T, 
         show_rownames = T,
        show_colnames = F,
        labels_row = sig_norm$gene,
         annotation = cluster_metadata[, c("condition", "cluster_id")], 
         border_color = NA, 
         fontsize = 10, 
         scale = "row", 
         fontsize_row = 8, 
         height = 20)    
```
```{r}
ggsave(heatmap_basal, filename = "../results/Basal_heatmap05.pdf", device = "pdf", height = 6, width = 6)
```

### Volcano Plot

```{r}
volcano_basal <- EnhancedVolcano(res_tbl,
                lab = res_tbl$gene,
                x = 'log2FoldChange',
                y= 'padj',
                xlim = c(-3,3),
                title = "",
                subtitle = "Basal (34 Up, 21 Down)",
                caption = "",
                hlineCol = 'black',
                vlineCol = 'black',
                colAlpha = 4/5,
                FCcutoff = 1,
                pCutoff = 0.05,
                pointSize = 1.5,
                labCol = 'black',
                cutoffLineCol = 'black',
                border = "full",
                col = c("grey30", "#EEC537", "#8AC1BE", "#D7462E"),
                legendPosition = 'none',
                drawConnectors = F,
                selectLab = ""
            )
volcano_basal
```
```{r}
ggsave(volcano_basal, filename = "../results/Basal_volcano05.pdf", device = "pdf", height = 6, width = 6)
```




# Ciliated cells
We see multiple different immune cell types in our dataset. Let’s perform the DE analysis on the first element in our vector. Let’s extract the first eleement from the vector:
```{r}
clusters[2]
```

We can use this output to run the DE analysis on the first cluster. First we can subset the metadata and the counts to only the cells in the first cluster.
```{r}
# Subset the metadata to only the B cells
cluster_metadata <- metadata[which(metadata$cluster_id == clusters[2]), ]
head(cluster_metadata)

# Assign the rownames of the metadata to be the sample IDs
rownames(cluster_metadata) <- cluster_metadata$sample
cluster_metadata

# Subset the counts to only the B cells
counts <- pb[[clusters[2]]]

cluster_counts <- as.data.frame(as.matrix(counts[, which(colnames(counts) %in% rownames(cluster_metadata))]))

# Check that all of the row names of the metadata are the same and in the same order as the column names of the counts in order to use as input to DESeq2
all(rownames(cluster_metadata) == colnames(cluster_counts))         
```

## Create DESeq2 object
Now we can create our DESeq2 object to prepare to run the DE analysis. We need to include the counts, metadata, and design formula for our comparison of interest. In the design formula we should also include any other columns in the metadata for which we want to regress out the variation (e.g. batch, sex, age, etc.). We only have our comparison of interest, which is stored as the condition in our metadata data frame.

```{r}
# Create DESeq2 object        
dds <- DESeqDataSetFromMatrix(cluster_counts, 
                              colData = cluster_metadata, 
                              design = ~ condition)
```

```{r}
dds$condition<- relevel(dds$condition, ref = "ana")
```

## Quality Control
The next step in the DESeq2 workflow is QC, which includes sample-level and gene-level QC checks on the count data to help us ensure that the samples/replicates look good.

### Sample level
A useful initial step in an RNA-seq analysis is to assess overall similarity between samples:
 - Which samples are similar to each other, which are different?
 - Does this fit the expectation from the experiment’s design?
 - What are the major sources of variation in the dataset?
 
To explore the similarity of our samples, we will be performing sample-level QC using Principal Component Analysis (PCA) and hierarchical clustering methods. Sample-level QC allows us to see how well our replicates cluster together, as well as, observe whether our experimental condition represents the major source of variation in the data. Performing sample-level QC can also identify any sample outliers, which may need to be explored further to determine whether they need to be removed prior to DE analysis.

### PCA
We can run the rlog() function from DESeq2 to normalize and rlog transform the raw counts. Then, we can use the plotPCA() function to plot the first two principal components.
```{r}
# Transform counts for data visualization
rld <- rlog(dds, blind=TRUE)

# Plot PCA
DESeq2::plotPCA(rld, intgroup = "condition")
```

### Hierarchical clustering
Samples below 0.80 may indicate an outlier in your data and/or sample contamination.

The hierarchical tree can indicate which samples are more similar to each other based on the normalized gene expression values. The color blocks indicate substructure in the data, and you would expect to see your replicates cluster together as a block for each sample group. Additionally, we expect to see samples clustered similar to the groupings observed in a PCA plot.
```{r}
# Extract the rlog matrix from the object and compute pairwise correlation values
rld_mat <- assay(rld)
rld_cor <- cor(rld_mat)

# Plot heatmap
pheatmap(rld_cor, annotation = cluster_metadata[, c("condition"), drop=F])
```

## Running DESeq2
Briefly, DESeq2 will model the raw counts, using normalization factors (size factors) to account for differences in library depth. Then, it will estimate the gene-wise dispersions and shrink these estimates to generate more accurate estimates of dispersion to model the counts. Finally, DESeq2 will fit the negative binomial model and perform hypothesis testing using the Wald test or Likelihood Ratio Test.

```{r}
# Run DESeq2 differential expression analysis
dds <- DESeq(dds)
```

We can check the fit of the model to our data by looking at the plot of dispersion estimates.
```{r}
# Plot dispersion estimates
plotDispEsts(dds)
```

## Results
Now that we have performed the differential expression analysis, we can explore our results for a particular comparison. To denote our comparison of interest, we need to specify the contrast and perform shrinkage of the log2 fold changes.

```{r}
# Check the coefficients for the comparison
resultsNames(dds)
```


```{r}
# Generate results object
res <- results(dds, 
               name = "condition_fuso_vs_ana",
               alpha = 0.05)

# Shrink the log2 fold changes to be more appropriate using the apeglm method - should cite [paper]() when using this method
res <- lfcShrink(dds, 
                 coef = "condition_fuso_vs_ana",
                 res=res,
                 type = "apeglm")

```

### Table of results for all genes
```{r}
# Turn the results object into a tibble for use with tidyverse functions
res_tbl <- res %>%
  data.frame() %>%
  rownames_to_column(var="gene") %>%
  as_tibble() %>%
  arrange(padj) %>%
  left_join(annotations, by = c("gene" = "gene_name")) # Join annotation data to dataframe

# Check results output
res_tbl 

# Write all results to file
write.csv(res_tbl,
          paste0("../results/", clusters[2], "_all_genes.csv"),
          quote = FALSE, 
          row.names = FALSE)
```

### Table of results for significant genes
```{r}
# Set thresholds
padj_cutoff <- 0.05
l2fc.cutoff <- 1
##NOTE: Here we are just using a p-value cutoff to denote significance. We could also add a log2fc filter as well.

# Subset the significant results
sig_res <- dplyr::filter(res_tbl, padj < padj_cutoff & abs(log2FoldChange) > l2fc.cutoff) %>%
  dplyr::arrange(padj)

# Check significant genes output
sig_res

# Write significant results to file
write.csv(sig_res,
          paste0("../results/", clusters[2], "_sig_genes05.csv"),
          quote = FALSE, 
          row.names = FALSE)
```

### Scatterplot 
Now that we have identified the significant genes, we can plot a scatterplot of the top 20 significant genes. This plot is a good check to make sure that we are interpreting our fold change values correctly, as well.

```{r}
# Scatterplot
## ggplot of top genes
normalized_counts <- counts(dds, 
                            normalized = TRUE)

## Order results by padj values
top20_sig_genes <- sig_res %>%
  dplyr::arrange(padj) %>%
  dplyr::pull(gene) %>%
  head(n=20)


top20_sig_norm <- data.frame(normalized_counts) %>%
  rownames_to_column(var = "gene") %>%
  dplyr::filter(gene %in% top20_sig_genes)

gathered_top20_sig <- top20_sig_norm %>%
  gather(colnames(top20_sig_norm)[2:length(colnames(top20_sig_norm))], key = "samplename", value = "normalized_counts")

gathered_top20_sig <- inner_join(ei[, c("sample", "condition" )], gathered_top20_sig, by = c("sample" = "samplename"))

## plot using ggplot2
scatter_ciliated <- ggplot(gathered_top20_sig) +
  geom_point(aes(x = gene, 
                 y = normalized_counts, 
                 color = condition), 
             position=position_jitter(w=0.1,h=0)) +
  scale_y_log10() +
  xlab("Genes") +
  ylab("log10 Normalized Counts") +
  ggtitle("Top Significant DE Genes") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  theme(plot.title = element_text(hjust = 0.5))
scatter_ciliated
```
```{r}
ggsave(scatter_ciliated, filename = "../results/Ciliated_scatter05.pdf", device = "pdf", height = 6, width = 6)
```

```{r}
# get normalized counts to export
ciliated_norm <- data.frame(normalized_counts)

ciliated_sig_norm <- data.frame(normalized_counts) %>%
  rownames_to_column(var = "gene") %>%
  dplyr::filter(gene %in% sig_res$gene)

gathered_ciliated_sig <- ciliated_sig_norm %>%
  gather(colnames(ciliated_sig_norm)[2:length(colnames(ciliated_sig_norm))], key = "samplename", value = "normalized_counts")

gathered_ciliated_sig <- inner_join(ei[, c("sample", "condition" )], gathered_ciliated_sig, by = c("sample" = "samplename"))


gathered_ciliated <- ciliated_norm %>%
  gather(colnames(ciliated_norm)[2:length(colnames(ciliated_norm))], key = "samplename", value = "normalized_counts")

gathered_ciliated <- inner_join(ei[, c("sample", "condition" )], gathered_ciliated, by = c("sample" = "samplename"))

# Write results to file
write.csv(gathered_ciliated_sig,
          paste0("../results/", clusters[2], "_norm_sig.csv"),
          quote = FALSE, 
          row.names = FALSE)

write.csv(gathered_ciliated,
          paste0("../results/", clusters[2], "_norm.csv"),
          quote = FALSE, 
          row.names = FALSE)
```

### Heatmap
```{r}
# Extract normalized counts for only the significant genes
sig_norm <- data.frame(normalized_counts) %>%
  rownames_to_column(var = "gene") %>%
  dplyr::filter(gene %in% sig_res$gene)

# Set a color palette
heat_colors <- brewer.pal(6, "YlOrRd")

# Run pheatmap using the metadata data frame for the annotation
heatmap_ciliated <- pheatmap(sig_norm[ , 2:length(colnames(sig_norm))], 
         color = heat_colors, 
         cluster_rows = T, 
         show_rownames = T,
         show_colnames = F,
         labels_row = sig_norm$gene,
         annotation = cluster_metadata[, c("condition", "cluster_id")], 
         border_color = NA, 
         fontsize = 10, 
         scale = "row", 
         fontsize_row = 6, 
         height = 20)    
```
```{r}
ggsave(heatmap_ciliated, filename = "../results/Ciliated_heatmap05.pdf", device = "pdf", height = 6, width = 6)
```

### Volcano Plot

```{r}
volcano_ciliated <- EnhancedVolcano(res_tbl,
                lab = res_tbl$gene,
                x = 'log2FoldChange',
                y= 'padj',
                xlim = c(-3,3),
                title = "",
                subtitle = "Ciliated (217 Up, 23 Down)",
                caption = "",
                hlineCol = 'black',
                vlineCol = 'black',
                colAlpha = 4/5,
                FCcutoff = 1,
                pCutoff = 0.05,
                pointSize = 1.5,
                labCol = 'black',
                cutoffLineCol = 'black',
                border = "full",
                col = c("grey30", "#EEC537", "#8AC1BE", "#D7462E"),
                legendPosition = 'none',
                drawConnectors = F,
                selectLab = ""
                
            )
volcano_ciliated
```
```{r}
ggsave(volcano_ciliated, filename = "../results/Ciliated_volcano05.pdf", device = "pdf", height = 6, width = 6)
```


# Ionocytes
We see multiple different immune cell types in our dataset. Let’s perform the DE analysis on the first element in our vector. Let’s extract the first eleement from the vector:
```{r}
clusters[3]
```

We can use this output to run the DE analysis on the first cluster. First we can subset the metadata and the counts to only the cells in the first cluster.
```{r}
# Subset the metadata to only the B cells
cluster_metadata <- metadata[which(metadata$cluster_id == clusters[3]), ]
head(cluster_metadata)

# Assign the rownames of the metadata to be the sample IDs
rownames(cluster_metadata) <- cluster_metadata$sample
cluster_metadata

# Subset the counts to only the B cells
counts <- pb[[clusters[3]]]

cluster_counts <- as.data.frame(as.matrix(counts[, which(colnames(counts) %in% rownames(cluster_metadata))]))

# Check that all of the row names of the metadata are the same and in the same order as the column names of the counts in order to use as input to DESeq2
all(rownames(cluster_metadata) == colnames(cluster_counts))         
```

## Create DESeq2 object
Now we can create our DESeq2 object to prepare to run the DE analysis. We need to include the counts, metadata, and design formula for our comparison of interest. In the design formula we should also include any other columns in the metadata for which we want to regress out the variation (e.g. batch, sex, age, etc.). We only have our comparison of interest, which is stored as the condition in our metadata data frame.

```{r}
# Create DESeq2 object        
dds <- DESeqDataSetFromMatrix(cluster_counts, 
                              colData = cluster_metadata, 
                              design = ~ condition)
```

```{r}
dds$condition<- relevel(dds$condition, ref = "ana")
```

## Quality Control
The next step in the DESeq2 workflow is QC, which includes sample-level and gene-level QC checks on the count data to help us ensure that the samples/replicates look good.

### Sample level
A useful initial step in an RNA-seq analysis is to assess overall similarity between samples:
 - Which samples are similar to each other, which are different?
 - Does this fit the expectation from the experiment’s design?
 - What are the major sources of variation in the dataset?
 
To explore the similarity of our samples, we will be performing sample-level QC using Principal Component Analysis (PCA) and hierarchical clustering methods. Sample-level QC allows us to see how well our replicates cluster together, as well as, observe whether our experimental condition represents the major source of variation in the data. Performing sample-level QC can also identify any sample outliers, which may need to be explored further to determine whether they need to be removed prior to DE analysis.

### PCA
We can run the rlog() function from DESeq2 to normalize and rlog transform the raw counts. Then, we can use the plotPCA() function to plot the first two principal components.
```{r}
# Transform counts for data visualization
rld <- rlog(dds, blind=TRUE)

# Plot PCA
DESeq2::plotPCA(rld, intgroup = "condition")
```

### Hierarchical clustering
Samples below 0.80 may indicate an outlier in your data and/or sample contamination.

The hierarchical tree can indicate which samples are more similar to each other based on the normalized gene expression values. The color blocks indicate substructure in the data, and you would expect to see your replicates cluster together as a block for each sample group. Additionally, we expect to see samples clustered similar to the groupings observed in a PCA plot.
```{r}
# Extract the rlog matrix from the object and compute pairwise correlation values
rld_mat <- assay(rld)
rld_cor <- cor(rld_mat)

# Plot heatmap
pheatmap(rld_cor, annotation = cluster_metadata[, c("condition"), drop=F])
```

## Running DESeq2
Briefly, DESeq2 will model the raw counts, using normalization factors (size factors) to account for differences in library depth. Then, it will estimate the gene-wise dispersions and shrink these estimates to generate more accurate estimates of dispersion to model the counts. Finally, DESeq2 will fit the negative binomial model and perform hypothesis testing using the Wald test or Likelihood Ratio Test.

```{r}
# Run DESeq2 differential expression analysis
dds <- DESeq(dds)
```

We can check the fit of the model to our data by looking at the plot of dispersion estimates.
```{r}
# Plot dispersion estimates
plotDispEsts(dds)
```

## Results
Now that we have performed the differential expression analysis, we can explore our results for a particular comparison. To denote our comparison of interest, we need to specify the contrast and perform shrinkage of the log2 fold changes.

```{r}
# Check the coefficients for the comparison
resultsNames(dds)
```


```{r}
# Generate results object
res <- results(dds, 
               name = "condition_fuso_vs_ana",
               alpha = 0.05)

# Shrink the log2 fold changes to be more appropriate using the apeglm method - should cite [paper]() when using this method
res <- lfcShrink(dds, 
                 coef = "condition_fuso_vs_ana",
                 res=res,
                 type = "apeglm")

```

### Table of results for all genes
```{r}
# Turn the results object into a tibble for use with tidyverse functions
res_tbl <- res %>%
  data.frame() %>%
  rownames_to_column(var="gene") %>%
  as_tibble() %>%
  arrange(padj) %>%
  left_join(annotations, by = c("gene" = "gene_name")) # Join annotation data to dataframe

# Check results output
res_tbl 

# Write all results to file
write.csv(res_tbl,
          paste0("../results/", clusters[3], "_all_genes.csv"),
          quote = FALSE, 
          row.names = FALSE)
```

### Table of results for significant genes
```{r}
# Set thresholds
padj_cutoff <- 0.05
l2fc.cutoff <- 1
##NOTE: Here we are just using a p-value cutoff to denote significance. We could also add a log2fc filter as well.

# Subset the significant results
sig_res <- dplyr::filter(res_tbl, padj < padj_cutoff & abs(log2FoldChange) > l2fc.cutoff) %>%
  dplyr::arrange(padj)

# Check significant genes output
sig_res

# Write significant results to file
write.csv(sig_res,
          paste0("../results/", clusters[3], "_sig_genes05.csv"),
          quote = FALSE, 
          row.names = FALSE)
```


### Volcano Plot

```{r}
volcano_ionocytes <- EnhancedVolcano(res_tbl,
                lab = res_tbl$gene,
                x = 'log2FoldChange',
                y= 'padj',
                xlim = c(-3,3),
                title = "",
                subtitle = "",
                caption = "",
                hlineCol = 'black',
                vlineCol = 'black',
                colAlpha = 4/5,
                FCcutoff = 1,
                pCutoff = 0.05,
                pointSize = 1.5,
                labCol = 'black',
                cutoffLineCol = 'black',
                border = "full",
                col = c("grey30", "#EEC537", "#8AC1BE", "#D7462E"),
                legendPosition = 'none',
                  drawConnectors = F,
                labSize = 3.0
            )
volcano_ionocytes
```
```{r}
ggsave(volcano_ionocytes, filename = "../results/Ionocytes_volcano05.pdf", device = "pdf", height = 6, width = 6)
```


# Secretory cells
We see multiple different immune cell types in our dataset. Let’s perform the DE analysis on the first element in our vector. Let’s extract the first eleement from the vector:
```{r}
clusters[4]
```

We can use this output to run the DE analysis on the first cluster. First we can subset the metadata and the counts to only the cells in the first cluster.
```{r}
# Subset the metadata to only the B cells
cluster_metadata <- metadata[which(metadata$cluster_id == clusters[4]), ]
head(cluster_metadata)

# Assign the rownames of the metadata to be the sample IDs
rownames(cluster_metadata) <- cluster_metadata$sample
cluster_metadata

# Subset the counts to only the B cells
counts <- pb[[clusters[4]]]

cluster_counts <- as.data.frame(as.matrix(counts[, which(colnames(counts) %in% rownames(cluster_metadata))]))

# Check that all of the row names of the metadata are the same and in the same order as the column names of the counts in order to use as input to DESeq2
all(rownames(cluster_metadata) == colnames(cluster_counts))         
```

## Create DESeq2 object
Now we can create our DESeq2 object to prepare to run the DE analysis. We need to include the counts, metadata, and design formula for our comparison of interest. In the design formula we should also include any other columns in the metadata for which we want to regress out the variation (e.g. batch, sex, age, etc.). We only have our comparison of interest, which is stored as the condition in our metadata data frame.

```{r}
# Create DESeq2 object        
dds <- DESeqDataSetFromMatrix(cluster_counts, 
                              colData = cluster_metadata, 
                              design = ~ condition)
```

```{r}
dds$condition<- relevel(dds$condition, ref = "ana")
```

## Quality Control
The next step in the DESeq2 workflow is QC, which includes sample-level and gene-level QC checks on the count data to help us ensure that the samples/replicates look good.

### Sample level
A useful initial step in an RNA-seq analysis is to assess overall similarity between samples:
 - Which samples are similar to each other, which are different?
 - Does this fit the expectation from the experiment’s design?
 - What are the major sources of variation in the dataset?
 
To explore the similarity of our samples, we will be performing sample-level QC using Principal Component Analysis (PCA) and hierarchical clustering methods. Sample-level QC allows us to see how well our replicates cluster together, as well as, observe whether our experimental condition represents the major source of variation in the data. Performing sample-level QC can also identify any sample outliers, which may need to be explored further to determine whether they need to be removed prior to DE analysis.

### PCA
We can run the rlog() function from DESeq2 to normalize and rlog transform the raw counts. Then, we can use the plotPCA() function to plot the first two principal components.
```{r}
# Transform counts for data visualization
rld <- rlog(dds, blind=TRUE)

# Plot PCA
DESeq2::plotPCA(rld, intgroup = "condition")
```

### Hierarchical clustering
Samples below 0.80 may indicate an outlier in your data and/or sample contamination.

The hierarchical tree can indicate which samples are more similar to each other based on the normalized gene expression values. The color blocks indicate substructure in the data, and you would expect to see your replicates cluster together as a block for each sample group. Additionally, we expect to see samples clustered similar to the groupings observed in a PCA plot.
```{r}
# Extract the rlog matrix from the object and compute pairwise correlation values
rld_mat <- assay(rld)
rld_cor <- cor(rld_mat)

# Plot heatmap
pheatmap(rld_cor, annotation = cluster_metadata[, c("condition"), drop=F])
```

## Running DESeq2
Briefly, DESeq2 will model the raw counts, using normalization factors (size factors) to account for differences in library depth. Then, it will estimate the gene-wise dispersions and shrink these estimates to generate more accurate estimates of dispersion to model the counts. Finally, DESeq2 will fit the negative binomial model and perform hypothesis testing using the Wald test or Likelihood Ratio Test.

```{r}
# Run DESeq2 differential expression analysis
dds <- DESeq(dds)
```

We can check the fit of the model to our data by looking at the plot of dispersion estimates.
```{r}
# Plot dispersion estimates
plotDispEsts(dds)
```

## Results
Now that we have performed the differential expression analysis, we can explore our results for a particular comparison. To denote our comparison of interest, we need to specify the contrast and perform shrinkage of the log2 fold changes.

```{r}
# Check the coefficients for the comparison
resultsNames(dds)
```


```{r}
# Generate results object
res <- results(dds, 
               name = "condition_fuso_vs_ana",
               alpha = 0.05)

# Shrink the log2 fold changes to be more appropriate using the apeglm method - should cite [paper]() when using this method
res <- lfcShrink(dds, 
                 coef = "condition_fuso_vs_ana",
                 res=res,
                 type = "apeglm")

```

### Table of results for all genes
```{r}
# Turn the results object into a tibble for use with tidyverse functions
res_tbl <- res %>%
  data.frame() %>%
  rownames_to_column(var="gene") %>%
  as_tibble() %>%
  arrange(padj) %>%
  left_join(annotations, by = c("gene" = "gene_name")) # Join annotation data to dataframe

# Check results output
res_tbl 

# Write all results to file
write.csv(res_tbl,
          paste0("../results/", clusters[4], "_all_genes.csv"),
          quote = FALSE, 
          row.names = FALSE)
```

### Table of results for significant genes
```{r}
# Set thresholds
padj_cutoff <- 0.05
l2fc.cutoff <- 1
##NOTE: Here we are just using a p-value cutoff to denote significance. We could also add a log2fc filter as well.

# Subset the significant results
sig_res <- dplyr::filter(res_tbl, padj < padj_cutoff & abs(log2FoldChange) > l2fc.cutoff) %>%
  dplyr::arrange(padj)

# Check significant genes output
sig_res

# Write significant results to file
write.csv(sig_res,
          paste0("../results/", clusters[4], "_sig_genes05.csv"),
          quote = FALSE, 
          row.names = FALSE)
```

### Scatterplot 
Now that we have identified the significant genes, we can plot a scatterplot of the top 20 significant genes. This plot is a good check to make sure that we are interpreting our fold change values correctly, as well.

```{r}
# Scatterplot
## ggplot of top genes
normalized_counts <- counts(dds, 
                            normalized = TRUE)

## Order results by padj values
top20_sig_genes <- sig_res %>%
  dplyr::arrange(padj) %>%
  dplyr::pull(gene) %>%
  head(n=20)


top20_sig_norm <- data.frame(normalized_counts) %>%
  rownames_to_column(var = "gene") %>%
  dplyr::filter(gene %in% top20_sig_genes)

gathered_top20_sig <- top20_sig_norm %>%
  gather(colnames(top20_sig_norm)[2:length(colnames(top20_sig_norm))], key = "samplename", value = "normalized_counts")

gathered_top20_sig <- inner_join(ei[, c("sample", "condition" )], gathered_top20_sig, by = c("sample" = "samplename"))

## plot using ggplot2
scatter_sec<- ggplot(gathered_top20_sig) +
  geom_point(aes(x = gene, 
                 y = normalized_counts, 
                 color = condition), 
             position=position_jitter(w=0.1,h=0)) +
  scale_y_log10() +
  xlab("Genes") +
  ylab("log10 Normalized Counts") +
  ggtitle("Top Significant DE Genes") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  theme(plot.title = element_text(hjust = 0.5))
scatter_sec
```
```{r}
ggsave(scatter_sec, filename = "../results/Secretory_scatter05.pdf", device = "pdf", height = 6, width = 6)
```

```{r}
# get normalized counts to export
secretory_norm <- data.frame(normalized_counts)

secretory_sig_norm <- data.frame(normalized_counts) %>%
  rownames_to_column(var = "gene") %>%
  dplyr::filter(gene %in% sig_res$gene)

gathered_secretory_sig <- secretory_sig_norm %>%
  gather(colnames(secretory_sig_norm)[2:length(colnames(secretory_sig_norm))], key = "samplename", value = "normalized_counts")

gathered_secretory_sig <- inner_join(ei[, c("sample", "condition" )], gathered_secretory_sig, by = c("sample" = "samplename"))


gathered_secretory <- secretory_norm %>%
  gather(colnames(secretory_norm)[2:length(colnames(secretory_norm))], key = "samplename", value = "normalized_counts")

gathered_secretory <- inner_join(ei[, c("sample", "condition" )], gathered_secretory, by = c("sample" = "samplename"))

# Write results to file
write.csv(gathered_secretory_sig,
          paste0("../results/", clusters[4], "_norm_sig.csv"),
          quote = FALSE, 
          row.names = FALSE)

write.csv(gathered_secretory,
          paste0("../results/", clusters[4], "_norm.csv"),
          quote = FALSE, 
          row.names = FALSE)
```

### Heatmap
```{r}
# Extract normalized counts for only the significant genes
sig_norm <- data.frame(normalized_counts) %>%
  rownames_to_column(var = "gene") %>%
  dplyr::filter(gene %in% sig_res$gene)

# Set a color palette
heat_colors <- brewer.pal(6, "YlOrRd")

# Run pheatmap using the metadata data frame for the annotation
heatmap_sec <- pheatmap(sig_norm[ , 2:length(colnames(sig_norm))], 
         color = heat_colors, 
         cluster_rows = T, 
         show_rownames = T,
         show_colnames = F,
         labels_row = sig_norm$gene,
         annotation = cluster_metadata[, c("condition", "cluster_id")], 
         border_color = NA, 
         fontsize = 10, 
         scale = "row", 
         fontsize_row = 6, 
         height = 20)    
heatmap_sec
```
```{r}
ggsave(heatmap_sec, filename = "../results/Secretory_heatmap05.pdf", device = "pdf", height = 6, width = 6)
```

### Volcano Plot


```{r}
volcano_sec <- EnhancedVolcano(res_tbl,
                lab = res_tbl$gene,
                x = 'log2FoldChange',
                y= 'padj',
                xlim = c(-3,3),
                title = "",
                subtitle = "Secretory (77 Up, 10 Down)",
                caption = "",
                hlineCol = 'black',
                vlineCol = 'black',
                colAlpha = 4/5,
                FCcutoff = 1,
                pCutoff = 0.05,
                pointSize = 1.5,
                labCol = 'black',
                cutoffLineCol = 'black',
                border = "full",
                col = c("grey30", "#EEC537", "#8AC1BE", "#D7462E"),
                legendPosition = 'none',
                drawConnectors = F,
                selectLab = ""
            )
volcano_sec
```
```{r}
ggsave(volcano_sec, filename = "../results/Secretory_volcano05.pdf", device = "pdf", height = 6, width = 6)
```























# UMAP and heatmap
```{r}
# Select the RNA counts slot to be the default assay
DefaultAssay(seurat) <- "RNA"

# Normalize RNA data for visualization purposes
seurat <- ScaleData(seurat, verbose = FALSE)
```
```{r}
#save cell markers file
markers <- read.csv("../data/cellmarkers.csv")
```

```{r}
#save cell markers file
markers_abbr <- read.csv("../data/cellmarkers_abbr.csv")
```

```{r}
my_levels <- c("Ciliated", "Basal", "Ionocytes", "Secretory", "Unknown")
levels(seurat) <- my_levels
```

```{r}
# Plot the UMAP
umap <- DimPlot(object = seurat, 
        reduction = "umap", 
        label = F,
        label.size = 5,
        repel = TRUE) &  theme(axis.text = element_text(size = 15))
umap2 <- umap +  guides(color = guide_legend(override.aes = list(size=4), ncol=1) )
umap2
```
```{r}
ggsave(umap2, filename = "../results/umap_fuso_ana.pdf", device = "pdf", height = 4, width = 4)
```

```{r}
seurat@meta.data$condition2 <- ifelse(seurat@meta.data$condition == "ana", "Untreated", "Treated")


```


```{r}
# Plot the UMAP
umap <- DimPlot(object = seurat, 
        reduction = "umap", 
        label = F,
        repel = TRUE,
        
        group.by = "condition2") &  theme(axis.text = element_text(size = 15), legend.text = element_text(size = 12)) 
umap2 <- umap + labs(title ="")
umap2
```
```{r}
ggsave(umap2, filename = "../results/umap_group.pdf", device = "pdf", height = 4, width = 4)
```



```{r}
heat<- DoHeatmap(subset(seurat, downsample = 100), features = markers_abbr$Marker, group.by = "ident", label=F) & theme(axis.text.y = element_text(size = 5), legend.text = element_text(size = 12)) 
heat2 <- heat 
heat2
```
```{r}
ggsave(heat2, filename = "../results/heatmap_markers.pdf", device = "pdf", height = 4, width = 8)
```


